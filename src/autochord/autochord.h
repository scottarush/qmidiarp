/*
* AutoChord class is a singleton class that is the interface to/from
* the autochord classes and the QMidiArp application itself.
*/
#ifndef _AUTOCHORD_H
#define _AUTOCHORD_H

// #include "lv2/lv2plug.in/ns/ext/log/log.h"
#include <stdio.h>
#include <mutex>
#include <cstdint>
using namespace std;

#include "scale.h"
#include "arp_modes.h"

#define MAX_CHORD_NOTES 6

// Debug logging macros
#define DEBUG_MSG printf
// #define DEBUG_MSG


/**
 * enum matching the Autochord state parameter for the LV2 plugin.
 * Must match the property in the ttl file.
 */
typedef enum autochord_state_e {
    AUTOCHORD_OFF = 0,
    AUTOCHORD_PAD = 1,
    AUTOCHORD_ARP = 2
} autochord_state_t;

/**
 * enum matching the Autochord Scale parameter for the LV2 plugin
 * Must match the property in the ttl file.
 */
typedef enum autochord_lv2_scale_e {
    AUTOCHORD_LV2_SCALE_IONIAN = 0,
    AUTOCHORD_LV2_SCALE_DORIAN = 1,
    AUTOCHORD_LV2_SCALE_PHRYGIAN = 2,
    AUTOCHORD_LV2_SCALE_LYDIAN = 3,
    AUTOCHORD_LV2_SCALE_MIXOLYDIAN = 4,
    AUTOCHORD_LV2_SCALE_AEOLIAN = 5,
    AUTOCHORD_LV2_SCALE_LOCRIAN = 6
 } autochord_lv2_scale_t;

 #define MAX_NOTES_BUFFER_SIZE MAX_CHORD_NOTES*10

/**
 * data structure for notes buffer generated by the Autochord
 */
typedef struct autochord_notes_s {
    uint8_t numNotes;
    uint8_t notes[MAX_NOTES_BUFFER_SIZE];
    uint8_t velocities[MAX_NOTES_BUFFER_SIZE];
} autochord_notes_t;

/**
 * Singleton class definition
 */
class AutoChord {
public:
    static AutoChord* getInstance() {
        std::lock_guard<std::mutex> lock(mutex);
        if (instance == nullptr) {
            instance = new AutoChord();
        }
        return instance;
    }

    /////////////////////////////////////////////////////////////////////////////
    // Utility function ensures, that a (transposed) note is within
    // the <lower>..<upper> range.
    //
    // If the note is outside the range, it will be "trimmed" in the semitone
    // range, and the octave will be kept.
    /////////////////////////////////////////////////////////////////////////////
    uint8_t trimNote(uint8_t note, uint8_t lower, uint8_t upper);

    void setState(autochord_state_t state);
    autochord_state_t getState();

    void setExtension(mode_extensions_t ext);
    mode_extensions_t getExtension();

    void setScale(autochord_lv2_scale_t index);
    autochord_lv2_scale_t getScale();

    void setKeySignature(key_signature_t key);
    key_signature_t getKeySignature();

    
    void notePressed(uint8_t note,uint8_t velocity);

    void noteReleased(uint8_t note,uint8_t velocity);

    /**
     * Called on a key press
     */


    /**
     * Called to get the notes of the currently active chord, if any.
     * If no note is pressed then returns an empty buffer.
     */
    const autochord_notes_t* getChordNotes();

    /**
     * Called to get the nnotes to release in pad mode if any.
     */
    const autochord_notes_t* getPadNoteOffs();
    /**
     * Clears pad note on pending after the Note ons have been transmitted
     */
    void clearPadNoteOnPending();
    bool padNoteOnPending();
    /**
     * Clears pad note off pending after Note offs have been transmitted
     */
    void clearPadNoteOffPending();
    bool padNoteOffPending();

private:

    mode_extensions_t m_extension;
    autochord_state_t m_state;
    autochord_lv2_scale_t m_lv2scale;
    key_signature_t m_keySignature;

    uint8_t m_activeNote;
    uint8_t m_activeNoteVelocity;

    // Singleton members and private constructor
    static AutoChord* instance;
    static std::mutex mutex;
    AutoChord();

    void copyNotes(const autochord_notes_t* srcPtr,autochord_notes_t* destPtr);

    // buffer of active notes
    autochord_notes_t m_chordNotes;
    
    // buffer of pending off pad notes
    autochord_notes_t m_padOffNotes;

    // Pending transmit flags for On and Off notes
    bool m_padOnPending;

    void updateChordNotes();
};

#endif